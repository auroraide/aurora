% !TEX encoding = UTF-8 Unicode
\documentclass[parskip=full,11pt,twoside]{scrartcl}
\usepackage[utf8]{inputenc}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}
\usepackage[T1]{fontenc}
\usepackage[sfdefault]{roboto}
\usepackage[german]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\hypersetup{
	pdftitle={Implementierungsdokumentation},
	bookmarks=true,
}
\usepackage{csquotes}
\usepackage{upgreek}

\usepackage{amsmath} % for $\text{}$
\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}


\begin{titlepage}

\subject{Implementierungsdokumentation}
\title{\textbf{$\uplambda$}urora}
\subtitle{The Lambda Calculus IDE}


\author{Julia Patrusheva, Alexander von Heyden\\
Younis Bensalah, Max Nowak\\
Nikolai Polley, Randy Seng}

\end{titlepage}




\begin{document}
\maketitle
\tableofcontents
\newpage
%=====================EINLEITUNG=======================
\section{Einleitung}
Die Implementierungsphase.
Der Teil von PSE, in der wir damit anfangen, unserem Projekt Leben einzuhauchen, und mit einem funktionierenden Prototypen enden.
\newline

Wir haben uns darüber Gedanken gemacht, wie wir neben der eigentlichen Implementierung auch die sonst notwendige Aufgaben am besten bewerkstelligen können.
In den folgenden Paragraphen wird beschrieben, wie wir anhand unseres Entwurfs aus der vorherigen Phase vorgegangen sind.
Anfänglich kann man schon mal vorstellen, dass das Team sehr mit dem Entwurf zufrieden war und das meiste so, wie im Entwurf ausgelegt, implementiert werden konnte.
\newline
\newpage

%=====================ÄNDERUNGEN=====================
\section{Änderungen zum Entwurfsdokument}
Der Entwurf aus der vorherigen Phase hat sich als sehr zuverlässig und gut umsetzbar erwiesen.
Dennoch haben wir an einigen Stellen kleine Abänderungen vorgenommen, und ihn teilweise leicht erweitert.
Im Speziellen handelt es sich hierbei um folgendes:
\begin{itemize}
    \item CodeMirrorPanel (pkg: aurora.client.view.editor)
    \newline
    Ursprünglich war geplant, einen vorhandenen CodeMirror GWT Wrapper als dependency in Aurora einzubinden.
    Leider hat es sich herausgestellt, dass der Wrapper nicht nur auf einer alten Version von CodeMirror beruht, sondern scheinbar auch einen Bug hatte, der es uns erschwert hat, ihn ohne Fehler zu benutzen.
    Deswegen haben wir uns dazu entschieden, einen eigenen Wrapper für CodeMirror zu schreiben.
    Bei Bedarf könnte er wieder ausgegliedert werden, uns als dependency eingebunden werden.

	\item Umbennennung der Klasse aurora.backend.tree.Libraryterm
	\newline
	Zuallererst wurde diese Klasse von Libraryterm in Function umbenannt. Wir fanden es unschön, dass alle Klassen in dieser Package von Term erben, aber bei dieser Klasse dies extra dazustand. Auch ist für den abstrakten Syntaxbaum nicht relevant, ob die Funktion aus einer Library oder etwas anderem kommt. Deswegen wurde diese Klasse in Function umbenannt.

	\item Hinzufügung eines Attributs der Klasse aurora.backend.tree.Function
	\newline
	Viele Visitoren müssen den Funktionsnamen mit den Bibliotheken abgleichen und nachschauen, ob der Name der Funktion vorhanden ist und 		dann den Term bekommen, der mit dem Namen assoziiert ist. Da die Visitoren die Bibliotheken und den Presenter nicht kennen, müsste der 	Presenter jedem einzelnen Visitor die Bibliotheken übergeben. Da der Presenter auch immer nur die aktuellste Bibliothek kennt, würde 		es zu Schwierigkeiten kommen, wenn sich die Bibliothek während die Visitoren executen ändert.
	Deshalb werden jetzt schon beim Parsen den Funktionen ihre Terme, die sie repräsentieren, vom Presenter übergeben.
	Diese werden in Function.term gespeichert. Dannach kann nur ein neues parsen, welches einen neuen abstrakten syntaxbaum aufbauen würde 	die Funktionsassoziation ändern.
	\item Hinzufügung der Klasse aurora.backend.Comparer
	\newline
	Es wurde die Klasse Comparer geschrieben, die im Konstruktor zwei Terme erhält und diese dann mit der Methode compare() vergleicht. Die Methode gibt ein true zurück, wenn die zwei übergebenen Terme gleich waren, ein false wenn die zwei Terme nicht gleich waren. Diese Klasse wurde beim Debuggen benutzt, um zu testen ob die Reduktionsstrategien und die Betareduktion einen korrekten Term zurückgibt.

    \item Library wurde in HashLibrary umbenannt, dann ein Interface namens Library extrahiert. Es wurde MultiLibrary eingeführt, welche die Abrfrage von LibraryItems aus mehreren libraries erleichtern soll. Jetzt muss z.B. der LambdaParser nur eine Library als Konstruktor-Parameter annehmen, hinter der sich der Benutzer- und Standardbibliotheken verbergen. So können in Zukunft mehr Bibliotheken hinzugefügt werden, ohne den LambdaParser zu verändern.
    \newline

    \item Alle Share-Events übergeben jetzt den Step index anstatt ein HighligtedLambdaExpression. Auch wurden die Listen von HighlightedLambdaExpression aus den Share-Events entfernt, da der Presenter diese Informationen bereits hat. Die View soll keine Liste von Steps speichern, nur ihre GWT-spezifische Darstellung.

    \item Dem SidebarDisplay wurden mehrere neue Funktionen zur Behandlung von Fehlern hinzugefügt, die beim Hinzufügen einer neuen Benutzerbibliotheksfunktion entstehen können:
    	\texttt{displayAddLibraryItemSyntaxError} und \newline
        \texttt{displayAddLibraryItemSemanticError} werden aufgerufen wenn Lexen oder Parsen fehlschlägt.
        \texttt{displayAddLibraryItemNameAlreadyTaken} wird aufgerufen wenn es den gewünschten Funktionsnamen bereits in der Standard- oder Benutzerbibliotk gibt.

    \item Es sind ein paar Events, die bei dem Entwurf nicht bedacht wurden, 	hinzugekommen.
\end{itemize}



%=============IMPLEMENTIERUNGSPROZESS=====================
\section{Implementierungsprozess}
\subsection{Regeln während der Implementierung}
Bevor wir mit der Implementierung begonnen haben, haben wir uns gemeinsam dafür entschieden, wärend des gesamten Prozesses einige grundlegende Regeln einzuhalten.
Hiervon haben wir uns einen saubereren Implementierungsprozess erhofft.
Wichtig waren vorallem folgende Regeln:
\begin{itemize}
	\item Alle haben die benötigten Tools korrekt installiert
	\newline
	Am ersten Treffen mussten alle Teammitglieder die benötigten Tools installieren und testen ob sie funktionieren.
	Alle Teammitglieder mussten ein Mergetool installiert haben, weil es bereits Probleme im Entwurf wegen fehlerhaften Merges gegeben hatte.
	Auch mussten die Teammitglieder alle Funktionen auf der Kommandozeile zusätzlich 	zu der IDE ausführen können. Dies wurde vorrausgesetzt, um mögliche Fehler von den IDEs ausschließten zu können.
	Tools wie Ant, Ivy, Codemirror, Checkstyle, mussten zusätzlich installiert und eingerichtet werden.
	Natürlich musste auch GWT installiert und in die IDE eingebunden werden.

    \item Protected master
        \newline
        Der git master branch wurde so konfiguriert, dass nur noch die Phasenverantwortlichen andere Branches in den master mergen konnten.
        Auf dem master selber durfte nicht geschrieben werde.
    \item Checkstyle
    \newline
    Wir haben uns für die Checkstyleregeln von Google entschieden. Nur die maximale Linienlänge haben wir von 100 auf 120 Zeichen erhöht, da wir alle mit Widescreen Monitoren arbeiten und entwickeln. Die Checkstyleregeln waren Pflicht und mussten von allen Gruppenmitgliedern eingehalten werden.
    \item Git CI runner
        \newline
        In unserem git Repository haben wir einen CI Runner eingerichtet, der für alle Commits Aurora kompiliert hat, unsere Testfälle durchgegangen ist, sowie Checkstyle überprüft hat.
        So konnten wir sicherstellen, dass nur guter Code in den master Branch gemerged wurde.

    \item Continuous Deployment
        \newline
        Auf einem externen Server hatten wir durchgehend den aktuellen master Commit bereitgestellt.
        Zum Einen hat uns dies erlaubt, Aurora ohne großen Aufwand auf verschiedenen Endgeräten zu testen.
        Zum Anderen haben wir dadurch gewährlsiten können, dass unser Code nicht nur lokal sondern auch von einem Server geladen ohne Fehler ausgeführt werden kann.

       \item JUnitTests
       \newline
      	Es wurde von den Backendentwickler, die komplett in Java programmieren, JUnit 4 Tests zu schreibne.
      	Es wurde zwar keine Testüberdeckung vorrausgesetzt, aber man musste kontrollieren, dass der Code bei normaler Bedienung fehlerfrei funktioniert.
      	 Die Algorithmen, die zum Parsen und zum Reduzieren benutzt werden mussten auf Implementierungsfehler übreprüft werden, damit korrekte Ergebnise beim berechnen eines Lambdaterms berechnet werden.
      	Da im Frontend keine schnellen JunitTests verwendet werden konnten, sollten die Entwickler von Hand testen, ob sich die Objekte verhalten, wie man es erwartet.
      	Falls benötigt mussten mit Mockito Klassen gemocket werden.
      	\item Issues
      	Wenn Probleme im Code von anderen Teammitgliedern gefunden wurden, mussten Issues in Gitlab geöffnet werden, damit keine Informationen verloren gehen konnten.
      	\end{itemize}

\subsection{Ursprünglicher Implementierungsplan}
Nachdem wir uns darauf geeinigt hatten, wie der Implementierungsprozess ablaufen sollte, mussten wir uns nun dafür entscheiden, was von wem implementiert werden musste.
Hierzu haben wir uns an die in der Entwurfsphase erstellte Struktur gehalten, und Pakete einzelnen Personen zugewiesen.
Wir haben versucht abzuschätzen wie viel Aufwand die jeweiligen Pakete darstellen und haben so verteilt, dass möglicht alle Gruppenmitglieder gleich viel Arbeit zu verrichten hatten.
Die Personen hatten bei ihren zugeteilten Paketen auch beim Entwurf mitgearbeitet, damit Wissen aus dem Entwurf nicht verloren gehen konnte.
Kleinere Pakete wurden direkt einer Person zugeteilt, wohingegen größere Pakete immer noch ein weiterer \enquote{Helfer} zugeteilt wurde.
Die Personen haben dann jeweils in ihren Pakten Prioritäten festgelegt, um eine Reihenfolge der Implementierung festzulegen.

Es mussten hierbei natürlich auch die Abhängigkeiten der Pakete beachtet werden, damit man die Pakete möglichst schnell testen kann.


\subsubsection{Verteilung der Pakete und deren Priorität}
Im Folgenden ist das Ergebnis unsere Paketeverteilung zu sehen.
\begin{description}


    \item [Alexander]\hfill \\
      wird zu großen Teilen die Darstellung des Editor Bereiches implementieren.
        Hierzu zählt zu aller erst das Anzeigen von Code, was unter anderem Zeilennummerierung und Syntaxhighlighting beinhaltet.
        Im Anschluss daran wird er den Encoder implentieren, der es erlauben wird, Sessions zu teilen.
    \item [Nikolai]\hfill \\
    \begin{enumerate}
    \item Churchnummern in Abstraktionsgestalt von den Integers in denen sie gespeichert sind generieren. \\(class aurora.backend.tree.Churchnumber)
    \item  Die Libraryfunktionen implementieren \\pkg: aurora.backend.library
    \item Die Redexpathklasse zu füllen \\class: aurora.backend.RedexPath
    \item Mit der fertigen RedexPathklasse die Normalorder implementieren. Die Normalorder erstellt als Ergebnis einen Redexpath. \\class: aurora.backend.betareduction.strategies.NormalOrder
    \item Wenn die Normalorder fertig ist die Betareducer klassepackage implementieren und dann mit der fertigen Normalorder testen. backend.betareduction
    \item Wenn dies klappt werden Call by Value und Call by Name implementiert  \\(pkg: aurora.backend.betareduction.strategies)
\item Dannach wird die User Strategy implementiert \\(pkg: aurora.backend.betareduction.strategies)

\item Die ShareLatex klasse wird implementiert \\(class: aurora.backend.ShareLatex)
    \end{enumerate}
Ich habe diese Reihenfolge gewählt, damit ich möglichst alles gleich testen konnte und deshalb habe ich die Abhängigkeiten zuerst implementiert.
    \item [Iuliia]\hfill \\
    \item [Max]\hfill \\
    \item [Younis]\hfill \\

    \item [Randy]\hfill \\
    \begin{enumerate}
    \item Einen Bug beheben, der beim Starten der Aurora WebApp, nicht die GUI, sondern eine blanke Seite anzeigt. Der Bug muss zuerst behoben werden, da sonst alle, die im Frontend, ihre Ergebnisse nicht einsehen können. Zuerst wurde vermutet, dass der Fehler sich im Package aurora.client.view befindet. Letzendlich hatte sich die Vermutung als falsch rausgestellt und der Fehler musste in der Klasse aurora.client.Aurora behoben werden. \\(pkg: aurora.client.Aurora)
    \item Die Aufgabe ist es, sich für die Benutzung von GWTTestCase zu informieren.
    \item Die State Machine in AuroraView implementieren. Die State Machine konnte unabhängig von allen anderen Klassen implementiert werden. \\(class: aurora.client.view.AuroraView)

    \end{enumerate}
\end{description}


\subsection{Änderungen des Implementierungsplans während der Implementierung}

\begin{description}

\item [Alexander]\hfill \\
\item [Nikolai]\hfill \\
Großteilig wurde sich an den Plan gehalten, es wurde nur Call By Name und Call by Value vor dem Betareducer geschrieben.
Es wurde  bemerkt, dass das Prinzip dieser Reduktionsstrategien sehr ähnlich zu der Normalenordnung war und zu dem Zeitpunkt es passender erschien diese zu implementieren als in ein komplett neues Thema einzusteigen.
Nach dem Betareduzierer wurde noch den Comparer geschrieben, der für einfacheres debuggen geeignet war. Ob er sich auch für den Simplifier eignet muss sich in der Qualitätssicherung zeigen.
Da bei der User Strategy Implemntierung des Frontends, Presenters und Backends benötigt wird und andere Teammitglieder, vitalere Dinge zu erledigen hatten
wurde die Implementierung dieser Reduktionsstrategie in die Qualitätssicherung verschoben.
Dannach wurde von Younis Aufgaben die Klasse HighlightedLambdaExpression gefüllt und  Highlightedlambdaexpression.toString(t) geschrieben, da die Aufgabenverteilung nicht ganz fair gelungen war, da unterschätzt worden war, wie aufwändig die Toolchain einzurichten war.

\item [Iuliia]\hfill \\
\item [Max]\hfill \\
\item [Younis]\hfill \\
\item [Randy]\hfill \\
\end{description}

\subsubsection{Unerwartete Probleme}
Während der Implementierung wurden nur wenige wirklich unerwartete Probleme gefunden, welche aber dafür um so mehr Zeit gekostet haben, um wirklich vollends behoben werden zu können:
\begin{itemize}
    \item ant (Buildsystem)
        \newline
        \textbf{Das sollte vllt. am besten Younis schreiben :)}
    \item Continuous Deployment
        \newline
        \textbf{Das vllt. auch...}
    \item Parser
        \newline
        \textbf{Younis?}
    \item CodeMirror
        \newline
        \textbf{Gerade kein Bock, schreib ich später. Alex}
    \item BetaReducer
    \newline
Es war bereits im Entwurf ein Prototyp eines Betareduzieres geschrieben worden und er hatte, mit etwas hardcoding, ein richtiges Ergebnis für eine Beispielrechnung geliefert. Dass dieses richtige Ergebnis purer Zufall war und dass der Betareduzierer falsch gerechnet hatte musste recht lange debuggt werden. Als das Problem stellte sich am Ende ein falscher Shift der DebruijnIndizes heraus, die nur bei manchen Reduktionen relevant waren und der Bug deswegen gut versteckt war.

\end{itemize}

\newpage


%=====================FEATURES=====================
\section{Implementierte Kriterien}

\subsection{Musskriterien}
Alle im Pflichtenheft definierten Musskriterien sind in der aktuellen Version von Aurora umgesetzt worden.

\subsection{Wunschkriterien}
Neben den Pflichtkriterien wurden in der ersten Phase auch Wunschkriterien definiert.
Im folgenden ist eine Auflistung aller implementierten Wunschkriterien zu sehen.
\newline
\newline
\textbf{K1} Zeilennummer
\newline
\textbf{K2} Kommentare einfügen
\newline
\textbf{K3} Autovervollständigung von Klammern
\newline
\textbf{K4} Syntax-Highlighting
\newline
\textbf{K7} Standardbibliothek
\newline
\textbf{K8} Benutzerbibliothek
\bigbreak
\textbf{K9} Call By Name und Call By Value
\smallbreak
\textbf{K11} Mehrere Schritte auswerten.
\newline

\subsection{Kriterien die wegfielen}
Es gibt zwar einige Wunschkriterien, die noch nicht implementiert wurden,
aber zu diesem Zeitpunkt wird kein Kriterium ausgeschlossen. Es wurde sich
vorgenommen die meisten Kriterien, die noch nicht implementiert wurden,
in der Qualitätstsicherungsphase zu implementieren.
Falls dennoch Wunschkriterien in der Qualitätssicherung wegfallen wird dies in der internen Abnahme notiert.
\newpage


%=====================STATISTIKEN=====================
\section{Statistiken}

\subsection{Continuous Integration}
Anzahl Commits: \textasciitilde  1200\newline

Anzahl MRs\newline
Anzahl pipes\newline


\subsection{Testabdeckung}
Das Package aurora.backend hat ungefähr 70 \% Codeüberdeckung.
Die Strategien, die einen Redexpath liefern und die Betareduktion wurden ausgiebig getestet.
Der Parser konnte zusätzlich einfach getestet werden, da er als Chatbot in einem Messenger integriert wurde.
Dort konnte die Teammitglieder korrekte und falsche eingaben parsen und schauen,
ob korrekt geparsed wurde.
Es wurden mehr als 127 Messages and den Bot geschickt und dadurch konnten zwei
Fehler des Parsers behoben werden.
Später wurde auch die Fähigkeit des Betareduzierens dem Bot hinzugefügt.
\newpage


\end{document}
