% !TEX encoding = UTF-8 Unicode
\documentclass[parskip=full,11pt,twoside]{scrartcl}
\usepackage[utf8]{inputenc}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}
\usepackage[T1]{fontenc}
\usepackage[sfdefault]{roboto}
\usepackage[german]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\hypersetup{
	pdftitle={Implementierungsdokumentation},
	bookmarks=true,
}
\usepackage{csquotes}
\usepackage{upgreek}

\usepackage{amsmath} % for $\text{}$
\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}


\begin{titlepage}

\subject{Implementierungsdokumentation}
\title{\textbf{$\uplambda$}urora}
\subtitle{The Lambda Calculus IDE}


\author{Julia Patrusheva, Alexander von Heyden\\
Younis Bensalah, Max Nowak\\
Nikolai Polley, Randy Seng}

\end{titlepage}




\begin{document}
\maketitle
\tableofcontents
\newpage
%=====================EINLEITUNG=======================
\section{Einleitung}
Die Implementierungsphase.
Der Teil von PSE, in der wir damit anfangen, unserem Projekt Leben einzuhauchen, und mit einem funktionierenden Prototypen enden.
\newline

Wir haben uns darüber Gedanken gemacht, wie wir neben der eigentlichen Implementierung auch die sonst notwendige Aufgaben am besten bewerkstelligen können.
In den folgenden Paragraphen wird beschrieben, wie wir anhand unseres Entwurfs aus der vorherigen Phase vorgegangen sind.
Anfänglich kann man schon mal vorstellen, dass das Team sehr mit dem Entwurf zufrieden war und das meiste so, wie im Entwurf ausgelegt, implementiert werden konnte.
\newline
\newpage

%=====================STATISTIKEN=====================
\section{Statistik}

\subsection{Continuous Integration}
Anzahl Commits: über 1000\newline
Anzahl MRs\newline
Anzahl pipes\newline

Fancy gitlab charts?

\subsection{Testabdekung}
Wenn Zeit ist, ansonsten kommt das weg.
Der Rest übrigens auch...

\newpage

%=====================FEATURES=====================
\section{Kriterien}

\subsection{Musskriterien}
Alle im Pflichtenheft definierten Musskriterien sind in der aktuellen Version von Aurora umgesetzt worden.

\subsection{Wunschkriterien}
Neben den Pflichtkriterien wurden in der ersten Phase auch Wunschkriterien definiert.
Im folgenden ist eine Auflistung aller implementierten Wunschkriterien zu sehen.
\newline
\newline
\textbf{K1} Zeilennummer
\newline
\textbf{K2} Kommentare einfügen
\newline
\textbf{K3} Autovervollständigung von Klammern
\newline
\textbf{K4} Syntax-Highlighting
\newline
\textbf{K7} Standardbibliothek \textbf{Max wie siehts aus, backend steht}
\newline
\textbf{K8} Benutzerbibliothek \textbf{max, wie siehts aus, backend steht?}
\bigbreak
\textbf{K9}Call By Name und Call By Value
\smallbreak
\textbf{K11} Mehrere Schritte auswerten \textbf{Max}
\newline
\newpage

%=====================ÄNDERUNGEN=====================
\section{Änderungen zum Entwurfsdokument}
Der Entwurf aus der vorherigen Phase hat sich als sehr zuverlässig und gut umsetzbar erwiesen.
Dennoch haben wir an einigen Stellen kleine Abänderungen vorgenommen, und ihn teilweise leicht erweitert.
Im Speziellen handelt es sich hierbei um folgendes:
\begin{itemize}
    \item CodeMirrorPanel (pkg: aurora.client.view.editor)
    \newline
    Ursprünglich war geplant, einen vorhandenen CodeMirror GWT Wrapper als dependency in Aurora einzubinden.
    Leider hat es sich herausgestellt, dass der Wrapper nicht nur auf einer alten Version von CodeMirror beruht, sondern scheinbar auch einen Bug hatte, der es uns erschwert hat, ihn ohne Fehler zu benutzen.
    Deswegen haben wir uns dazu entschieden, einen eigenen Wrapper für CodeMirror zu schreiben.
    Bei Bedarf könnte er wieder ausgegliedert werden, uns als dependency eingebunden werden.
	
	\item Umbennennung der Klasse aurora.backend.tree.Libraryterm
	\newline
	Zuallererst wurde diese Klasse von Libraryterm in Function umbenannt. Wir fanden es unschön, dass alle Klassen in dieser Package von Term erben, aber bei dieser Klasse dies extra dazustand. Auch ist für den abstrakten Syntaxbaum nicht relevant, ob die Funktion aus einer Library oder etwas anderem kommt. Deswegen wurde diese Klasse in Function umbenannt.
	
	\item Hinzufügung eines Attributs der Klasse aurora.backend.tree.Function
	\newline
	Viele Visitoren müssen den Funktionsnamen mit den Bibliotheken abgleichen und nachschauen, ob der Name der Funktion vorhanden ist und 		dann den Term bekommen, der mit dem Namen assoziiert ist. Da die Visitoren die Bibliotheken und den Presenter nicht kennen, müsste der 	Presenter jedem einzelnen Visitor die Bibliotheken übergeben. Da der Presenter auch immer nur die aktuellste Bibliothek kennt, würde 		es zu Schwierigkeiten kommen, wenn sich die Bibliothek während die Visitoren executen ändert. 
	Deshalb werden jetzt schon beim Parsen den Funktionen ihre Terme, die sie repräsentieren, vom Presenter übergeben.
	Diese werden in Function.term gespeichert. Dannach kann nur ein neues parsen, welches einen neuen abstrakten syntaxbaum aufbauen würde 	die Funktionsassoziation ändern.
	\item Hinzufügung der Klasse aurora.backend.Comparer
	\newline
	Es wurde die Klasse Comparer geschrieben, die im Konstruktor zwei Terme erhält und diese dann mit der Methode compare() vergleicht. Die Methode gibt ein true zurück, wenn die zwei übergebenen Terme gleich waren, ein false wenn die zwei Terme nicht gleich waren. Diese Klasse wurde beim Debuggen benutzt, um zu testen ob die Reduktionsstrategien und die Betareduktion einen korrekten Term zurückgibt.
	
    \item NEUE EVENTS???
\end{itemize}
\subsection{Kriterien die weggefallen sind (Krierien nummer + ein Grund)}
\newpage

%=============IMPLEMENTIERUNGSPROZESS=====================
\section{Implementierungsprozess}
\subsection{Regeln während der Implementierung}
Bevor wir mit der Implementierung begonnen haben, haben wir uns gemeinsam dafür entschieden, wärend des gesamten Prozesses einige grundlegende Regeln einzuhalten.
Hiervon haben wir uns einen saubereren Implementierungsprozess erhofft.
Wichtig waren vorallem folgende Regeln:
\begin{itemize}
	\item Alle haben die benötigten Tools korrekt installiert
	\newline
	Am ersten Treffen mussten alle Teammitglieder die benötigten Tools installieren und testen ob sie funktionieren. 
	Alle Teammitglieder mussten ein Mergetool installiert haben, weil es bereits Probleme im Entwurf wegen fehlerhaften Merges gegeben hatte.
	Auch mussten die Teammitglieder alle Funktionen auf der Kommandozeile zusätzlich 	zu der IDE ausführen können. Dies wurde vorrausgesetzt, um mögliche Fehler von den IDEs ausschließten zu können.
	Tools wie Ant, Ivy, Codemirror, Checkstyle, mussten zusätzlich installiert und eingerichtet werden. 
	Natürlich musste auch GWT installiert und in die IDE eingebunden werden. 
	
    \item Protected master
        \newline
        Der git master branch wurde so konfiguriert, dass nur noch die Phasenverantwortlichen andere Branches in den master mergen konnten. 
        Auf dem master selber durfte nicht geschrieben werde.
    \item Checkstyle
    \newline
    Wir haben uns für die Checkstyleregeln von Google entschieden. Nur die maximale Linienlänge haben wir von 100 auf 120 Zeichen erhöht, da wir alle mit Widescreen Monitoren arbeiten und entwickeln. Die Checkstyleregeln waren Pflicht und mussten von allen Gruppenmitgliedern eingehalten werden.
    \item Git CI runner
        \newline
        In unserem git Repository haben wir einen CI Runner eingerichtet, der für alle Commits Aurora kompiliert hat, unsere Testfälle durchgegangen ist, sowie Checkstyle überprüft hat.
        So konnten wir sicherstellen, dass nur guter Code in den master Branch gemerged wurde.
        
    \item Continuous Deployment
        \newline
        Auf einem externen Server hatten wir durchgehend den aktuellen master Commit bereitgestellt.
        Zum Einen hat uns dies erlaubt, Aurora ohne großen Aufwand auf verschiedenen Endgeräten zu testen.
        Zum Anderen haben wir dadurch gewährlsiten können, dass unser Code nicht nur lokal sondern auch von einem Server geladen ohne Fehler ausgeführt werden kann.
          
       \item JUnitTests
       \newline
      	Es wurde von den Backendentwickler, die komplett in Java programmieren, JUnit 4 Tests zu schreibne. 
      	Es wurde zwar keine Testüberdeckung vorrausgesetzt, aber man musste kontrollieren, dass der Code bei normaler Bedienung fehlerfrei funktioniert.
      	 Die Algorithmen, die zum Parsen und zum Reduzieren benutzt werden mussten auf Implementierungsfehler übreprüft werden, damit korrekte Ergebnise beim berechnen eines Lambdaterms berechnet werden.
      	Da im Frontend keine schnellen JunitTests verwendet werden konnten, sollten die Entwickler von Hand testen, ob die Objekte sich verhalten, wie man es erwartet. 
      	\item Issues
      	Wenn Probleme im Code von anderen Teammitgliedern gefunden wurden, mussten Issues in Gitlab geöffnet werden, damit keine Informationen verloren gehen konnten.
      	\end{itemize}

\subsection{Ursprünglicher Implementierungsplan}
Nachdem wir uns darauf geeinigt hatten, wie der Implementierungsprozess ablaufen sollte, mussten wir uns nun dafür entscheiden, was von wem implementiert werden musste.
Hierzu haben wir uns an die in der Entwurfsphase erstellte Struktur gehalten, und Pakete einzelnen Personen zugewiesen.
Wir haben versucht abzuschätzen wie viel Aufwand die jeweiligen Pakete darstellen und haben so verteilt, dass möglicht alle Gruppenmitglieder gleich viel Arbeit zu verrichten hatten.
Die Personen hatten bei ihren zugeteilten Paketen auch beim Entwurf mitgearbeitet, damit Wissen aus dem Entwurf nicht verloren gehen konnte.
Kleinere Pakete wurden direkt einer Person zugeteilt, wohingegen größere Pakete immer noch ein weiterer \enquote{Helfer} zugeteilt wurde. 
Die Personen haben dann jeweils in ihren Pakten Prioritäten festgelegt, um eine Reihenfolge der Implementierung festzulegen. 

Es mussten hierbei natürlich auch die Abhängigkeiten der Pakete beachtet werden, damit man die Pakete möglichst schnell testen kann.


\subsubsection{Verteilung der Pakete und deren Priorität}
Im Folgenden ist das Ergebnis unsere Paketeverteilung zu sehen.
\begin{description}


    \item [Alexander]\hfill \\
      wird zu großen Teilen die Darstellung des Editor Bereiches implementieren. 
        Hierzu zählt zu aller erst das Anzeigen von Code, was unter anderem Zeilennummerierung und Syntaxhighlighting beinhaltet.
        Im Anschluss daran wird er den Encoder implentieren, der es erlauben wird, Sessions zu teilen.
    \item [Nikolai]\hfill \\
    \begin{enumerate}
    \item Churchnummern in Abstraktionsgestalt von den Integers in denen sie gespeichert sind generieren. \\(class aurora.backend.tree.Churchnumber)
    \item  Die Libraryfunktionen implementieren \\pkg: aurora.backend.library
    \item Die Redexpathklasse zu füllen \\class: aurora.backend.RedexPath
    \item Mit der fertigen RedexPathklasse die Normalorder implementieren. Die Normalorder erstellt als Ergebnis einen Redexpath. \\class: aurora.backend.betareduction.strategies.NormalOrder
    \item Wenn die Normalorder fertig ist die Betareducer klassepackage implementieren und dann mit der fertigen Normalorder testen. backend.betareduction
    \item Wenn dies klappt werden Call by Value und Call by Name implementiert  \\(pkg: aurora.backend.betareduction.strategies)
\item Dannach wird die User Strategy implementiert \\(pkg: aurora.backend.betareduction.strategies)

\item Die ShareLatex klasse wird implementiert \\(class: aurora.backend.ShareLatex)
    \end{enumerate}
Ich habe diese Reihenfolge gewählt, damit ich möglichst alles gleich testen konnte und deshalb habe ich die Abhängigkeiten zuerst implementiert.
    \item [Iuliia]\hfill \\
    \item [Max]\hfill \\
    \item [Younis]\hfill \\

    \item [Randy]\hfill \\
    \begin{enumerate}
    \item Einen Bug beheben, der beim Starten der Aurora WebApp, nicht die GUI, sondern eine blanke Seite anzeigt. Der Bug muss zuerst behoben werden, da sonst alle, die im Frontend, ihre Ergebnisse nicht einsehen können. Zuerst wurde vermutet, dass der Fehler sich im Package aurora.client.view befindet. Letzendlich hatte sich die Vermutung als falsch rausgestellt und der Fehler musste in der Klasse aurora.client.Aurora behoben werden. \\(pkg: aurora.client.Aurora)
    \item Die Aufgabe ist es, sich für die Benutzung von GWTTestCase zu informieren. 
    \item Die State Machine in AuroraView implementieren. Die State Machine konnte unabhängig von allen anderen Klassen implementiert werden. \\(class: aurora.client.view.AuroraView) 

    \end{enumerate}
\end{description}


\subsubsection{Verteilung nach Module, die ungefähr unabhängig von ein ander implementiert werden können}

\subsection{Änderungen des Implementierungsplans während der Implementierung}

\subsubsection{Unerwartete Probleme}
Während der Implementierung sind wir nur auf wenige wirklich unerwartete Probleme gestoßen, die uns dafür aber um so mehr Zeit gekostet haben, um wirklich vollends behoben werden zu können:
\begin{itemize}
    \item ant (Buildsystem)
        \newline
        \textbf{Das sollte vllt. am besten Younis schreiben :)}
    \item Continuous Deployment
        \newline
        \textbf{Das vllt. auch...}
    \item Parser
        \newline
        \textbf{Younis?}
    \item CodeMirror
        \newline
        \textbf{Gerade kein Bock, schreib ich später. Alex}
    \item BetaReducer
    \newline
    Wir hatten im Entwurf bereits ein Prototyp eines Betareduzieres geschrieben und er hatte ein richtiges Ergebnis für eine Beispielrechnung geliefert. Dass dieses richtige Ergebnis purer Zufall war und dass der Betareduzierer falsch gerechnet hatte musste ich recht lange debuggen. Als das Problem stellte sich am Ende ein falscher Shift der DebruijnIndizes heraus, die nur bei manchen Reduktionen relevant sind.
   
\end{itemize}
\subsubsection{Ablauf der Implementierung}
\subsubsection{Was ist geändert und woran liegt es}
\subsubsection{git übersicht vll}
 (Realität und wieso es sich unterscheidet von dem Anfangsplan)
\newpage

%=====================UNIT TESTS=====================
\section{Unit tests}

\subsection{Backend TestZeug}
\subsubsection{Ziel}
\subsubsection{Voraussetzungen}
\subsubsection{Werkzeuge}
\subsection{Frontend TestZeug}
\subsubsection{Ziel}
\subsubsection{Voraussetzungen \& Probleme die auftauchen koennen}
\subsubsection{Werkzeuge}
\newpage

\end{document}
