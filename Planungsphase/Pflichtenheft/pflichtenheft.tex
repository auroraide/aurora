\documentclass[parskip=full,11pt,twoside]{scrartcl}
\usepackage[utf8]{inputenc}

\begin{titlepage}

\subject{Pflichtenheft}
\title{\textbf{$\uplambda$}urora}
\subtitle{The Lambda Calculus IDE}


\author{Alexander von Heyden, Julia Patrusheva\\
 Max Nowak, Nikolai Polley\\
 Randy Seng, Younis Bensalah}

\newpage
\end{titlepage}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}

\usepackage[sfdefault,light]{roboto}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\hypersetup{
	pdftitle={Pflichtenheft},
	bookmarks=true,
}
\usepackage{csquotes}

\usepackage{amsmath} % for $\text{}$
\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}
\usepackage{color}
\usepackage{upgreek}
\usepackage{pflichtenheft}




\begin{document}

\maketitle
\newpage
\tableofcontents

\newpage
\section{Einleitung}
Der Lehrstuhl für Programmierparadigmen am IPD Snelting ist seit Jahren dafür zuständig, Besuchern der gleichnamigen Vorlesung des $\lambda$-Kalkül zu vermitteln. Leider hat es sich in den vergangenen Jahren immer wieder gezeigt, dass eine erhebliche Anzahl von Studenten mit den grundlegenden Eigenschaften des $\lambda$-Kalküls Probleme haben. Hier versucht Aurora anzusetzen. Mit Hilfe einer einfach strukturierten Web App, die vom Design her an gängige IDEs angelehnt ist, soll dem Benutzer die Einführung in das $\lambda$-Kalkül erleichert werden. Hierfür wird dem Besucher eine Eingabemaske zur Verfügung gestellt, in die er eigene Terme eingeben kann. Schritt für Schritt kann er nun die Auswertung bis zum finalen Ergebnis verfolgen.


\newpage
\section{Zielsetzung}
% Diese Section sollte kurz und knapp "für Manager" sein
% und auf eine Seite passen.


\subsection{Musskriterien}

\criterium{Eingabe}{crt:text-editor}
Es gibt ein Eingabefeld um $\lambda$-Terme einzugeben.

\criterium{Input editieren}{crt:input-readonly}
Der Input kann nur bearbeitet werden, solange das Programm nicht rechnet.

\criterium{Output editieren}{crt:output-readonly}
Der Output kann nicht bearbeitet werden.

\criterium{Auswertung starten}{crt:run}
Der Benutzer kann die Auswertung des eingegebenen $\lambda$-Terms starten. Im Ausgabefenster erscheint das Ergebnis in Normalform.

\criterium{Auswertung stoppen}{crt:stop}
Der Benutzer kann die Auswertung des $\lambda$-Terms jederzeit stoppen.

\criterium{Zwischenschritte}{crt:intermediate-step-output}
Nach der Auswertung des $\lambda$-Terms können Zwischenergebnisse ausgegeben werden.

\criterium{Auswertungsstrategie}{crt:default-eval-strategy}
Die Auswertungsstrategie bei $\beta$-Reduktion von $\lambda$-Termen ist die Normalreihenfolge. Weitere Auswertungsstrategien sind in den Wunschkriterien.


\newpage
\subsection{Wunschkriterien}

\criteriumOptional{Zeilennummer}{crt:linenumbers}
Neben dem Eingabefeld soll ausgeblasst eine Zeilennumerierung dargestellt werden um eine einfache Zeilenzuteilung zu ermöglichen.

\criteriumOptional{Kommentare einfügen}{crt:comments}
Man kann eine Zeile in der Eingabe auskommentieren. Diese Zeile wird dann vom Parser übersprungen

\criteriumOptional{Autovervollständigung von Klammern}{crt:autobracket}
Wenn der Benutzer eine Klammer öffnet \enquote{(} dann schließt das Programm automatisch diese Klammer mit \enquote{)}

\criteriumOptional{Syntax-Highlighting}{crt:syntax-highlighting}
Schlüsselwörter aus den Bibliotheken und $\lambda$s werden farblich hervorgehoben. Beim hovern über einer Klammer wird das entsprechende Klammerpaar farblich hervorgehoben.

\criteriumOptional{Erweitertes Syntax-Highlighting}{crt:syntax-highlighting-premium}
Der nächste zu auszuwertende Redex wird farblich hinterlegt.
Außerder wird der reingezogene Term mit einer dritten Farbe im nächsten Schritt markiert.

\criteriumOptional{Pretty Print}{crt:pretty-print}
Die Ausgabe der Auswertungen von $\lambda$-Termen wird schön formatiert. Insbesondere wird das korrekte Einrücken der Zeilen gewährleistet.

\criteriumOptional{Standardbibliothek}{crt:std-library}
Bibliothek, in der vordefinierte Funktionen und Church-Zahlen verfügbar sind. Durch Schlüsselwörter kann der Benutzer diese direkt in seinen Code einbinden.

\criteriumOptional{Benutzerbibliothek}{crt:user-library}
Bibliothek, in der der Benutzer eigene Funktionen definieren, speichern und löschen kann. Durch Schlüsselwörter kann der Benutzer diese direkt in seinen Code einbinden.

\criteriumOptional{Weitere Auswertungsstrategien}{crt:opt-eval-strategy}
Zusätzliche Auswertungsstrategien sind \enquote{Call by Name} und \enquote{Call by Value}.

\criteriumOptional{Benutzerdefinierte Auswahl}{crt:own-eval-strategy}
Eigene Auswahl bei der $\beta$-Reduzierung eines Redex.

\criteriumOptional{Pause-Button}{crt:pause}
Der Pause-Button unterbricht die laufende Berechnung

\criteriumOptional{Share-Button}{crt:share}
Ein Share-Button ermöglicht das Erstellen von short-URLs sowie das Kopieren dieser in den Zwischenspeicher.

\criteriumOptional{Öffnen in neuem Tab}{crt:to-new-tab}
Im Kontextmenü zu den einzelnen Schritten kann der aktuelle Schritt als Eingabe in einem neuen Browser-Tab geöffnet werden.

\criteriumOptional{LaTeX export}{crt:export-latex}
$\lambda$-Terme aus dem Text-Editor oder der Schrittliste können in LaTeX-Snippet exportieren werden. Bis zu einer gewissen größe ist es auch möglich, den kompletten Rechenweg mit zu exportieren.

\criteriumOptional{Night Mode}{crt:night-mode}
Die Funktion \enquote{Night Mode} ändert das äußere Erscheinungsbild der Applikation zu einem dunkleren Farbschema.

\criteriumOptional{Schleifenerkennung}{crt:loop-detection}
Das Programm soll einfache Schleifen, wie z.B. ($\lambda$x. x x) ($\lambda$x. x x), erkennen. Insbesondere kann es aber weiterhin vorkommen, dass komplexere Schleifen nicht erkannt werden.
Außerdem soll das Programm nicht die Berechnunng abbrechen wenn eine Schleife gefunden wurde, sondern nur dem Nutzer die Option gegeben werden die Berechnung abzubrechen. Wenn der Benutzer  will kann er auch gefundene Endlosschleifen weiterlaufen lassen.

\criteriumOptional{$\lambda$urora Tutorial}{crt:tutorial}
Das Tutorial erklärt und zeigt dem Benutzer, wie man die Applikation $\lambda$urora nutzt.

\criteriumOptional{Sprachenauswahl im Programm}{crt:opt-language}
Der Benutzer soll neben der Default-Sprache Englisch auch die Möglichkeit haben, Deutsch, Französisch, oder Russisch auszuwählen.

\criteriumOptional{De Bruijn-Indizes}{crt:debruijn-output}
Ausgabe des Programmes kann wahlweise mit De Bruijn-Indizes erfolgen.

\criteriumOptional{Lokale Sessions}{crt:local-sessions}
Die Applikation merkt sich im localStorage des Webbrowsers die Historie von vorherigen Eingaben. Der Benutzer kann außerdem diese Historie verändern.

\criteriumOptional{Tastatur-Shortcuts}{crt:shortcuts}
$\lambda$urora stellt Tastatur-Shortcuts zum vereinfachten Ausführen von Features bereit.

\textbf{Verfügbare Tastatur-Shortcuts}

\label{shortcuts}
\begin{tabular}{|r|l|}

    \hline
    shortcut & Beschreibung \\ \hline
    \textbackslash & $\lambda$ \\ \hline
    Ctrl \enquote{+} $\hookleftarrow$ & Run \\ \hline
    Ctrl \enquote{+} t & Stopp \\ \hline
    Ctrl \enquote{+} p & Pause \\ \hline
    Ctrl \enquote{+} n & Schritt \\ \hline
    Ctrl \enquote{+} s & Speichern \\ \hline
    Ctrl \enquote{+} o & Öffnen \\ \hline

\end{tabular}



\subsection{Abgrenzungskriterien}

\criteriumNot{Berechnungen laufen Client-seitig}{crt:client-side}
Der Client führt das Programm aus. Alle Funktionen die etwas berechnen oder speichern müssen werden auf der Hardware des Clients ausgeführt.

\criteriumNot{Keine Server-Komponente}{crt:no-server-side}
Der Server ist nur für die Verbreitung des Programmcodes zuständig. Er selber speichert keinerlei Daten oder führt Aktionen für das Programm aus.

\criteriumNot{Kein typisiertes $\lambda$-Kalkül}{crt:no-typed-calculus}
Das Programm kann nur $\beta$-Reduktion des untypisierten $\lambda$-Kalküls durchführen. Auch eine einfache Erweiterungsschnittstelle, um z.B. Auswertungen des typisierten $\lambda$-Kalküls zu erlauben, ist nicht geplant und wird nicht bei Entwicklung des Programms in Betracht gezogen.

\criteriumNot{Applikation bietet keine Projekt-Unterstützung}{crt:no-projects}
Das Programm unterstützt keine Klassen oder anderweitig mehr als eine Eingabe oder mehrere Ausgabe.
Jede Instanz des Programmes ist nur auf die Nutzung durch eine Person ausgelegt. Es bietet keine Möglichkeiten zur Gruppenarbeit, lediglich durch die Share-Funktion und den LaTeX export kann Code geteilt werden.
\newline
Ein Versionskontrolle oder generelles Zusammenarbeiten über zwei Clients mit dem gleichen Programm ist nicht möglich.



\newpage
%%%%%%%%%%%%%%
\section{Produkteinsatz}

Wenn ein Interessierter das Programm benutzen will, dann benötigt er eine Internetanbindung. Er benötigt außerdem einen PC mit folgenden Spezifikationen: Wenn er Windows benutzt, dann Windows 7 oder höher, wenn er Mac benutzt dann OS X Mavericks 10.9 oder höher oder wenn er Linux benutzt Ubuntu 14.04 oder höher, Debian 8 oder höher, oder Fedora24 oder höher.
Er braucht zusätzlich einen SSE2-fähigen Intel Pentium 4-Prozessor oder besser.

\subsection{Anwendungsbereiche}

Der Anwendungsbereich umfasst die Studenten und wissenschaftlichen Mitarbeiter, die sich mit dem $\lambda$-Kalkül beschäftigen. Aurora erlaubt dem Benutzer $\lambda$-Terme zu berechnen und sich dabei einzelne Schritte der $\beta$-Reduktion anzeigen zu lassen. Durch vorhandene Shortcuts und eine mit grundlegenden Funktionen ausgestattete Standardbibliothek, soll die Benutzung der Aurora Web App den Benutzer an eine normale IDE erinnern, sodass schneller das gewünschte Ergebnis erreicht werden kann.

\subsection{Zielgruppen}

Zur Zielgruppe gehören vor allem Informatik-Studenten und wissenschaftliche Mitarbeiter, die sich mit dem $\lambda$-Kalkül beschäftigen und bereits gewisse Grundkenntnisse des $\lambda$-Kalküls besitzen. Auch anderweitig Interessierte sollen das Programm benutzen können.

Aurora ist für Einzelpersonen gedacht, eine Gruppenarbeit mit dem Programm (z.B. simultanes Bearbeiten) ist nicht möglich.

Für die Benutzung von Aurora werden Grundkenntnisse der Internetnutzung vorausgesetzt.

Die Sprache der Benutzeroberfläsche ist Englisch, daher sind Grundkenntnisse der Sprache von Vorteil.

\subsection{Betriebsbedingungen}

Aurora muss auf einem Web Server (z.B. Apache) gehostet werden und kann an beliebig viele Benutzer ausgeliefert werden.


\newpage
\section{Produktumgebung}
Aurora ist eine clientseitige Anwendung.

\subsection{Software}
	\begin{itemize}
		\item Es wird eines der gängigen Betriebssysteme benötigt:
		\begin{itemize}
			\item Windows 7 oder höher
			\item OS X Mavericks 10.9 oder höher
			\item Ubuntu 14.04 oder höher, Debian 8 oder höher, Fedora24 oder höher
		\end{itemize}
		\item Es wird ein gängiger Webbrowser benötigt, der HTML5, CSS3 und JavaScript unterstützt:
			\begin{itemize}
				\item Firefox (ab Version 57)
				\item Google Chrome (ab Version 62.0)
				\item Safari (ab Version 11.0.0)
			\end{itemize}
	\end{itemize}

\subsection{Hardware}
	\begin{itemize}
		\item Es wird ein an das Internet angeschlossener Rechner benötigt..
		\item Desweiteren wird ein SSE2-fähiger Intel Pentium 4-Prozessor oder besser benötigt.
	\end{itemize}
\subsection{Orgware}
	\begin{itemize}
		\item Während dem Projekt werden folgende Dokumente erstellt und dauernd gepflegt:
			\begin{itemize}
				\item Pflichtenheft
				\item Aurora Handbuch
			\end{itemize}
	\end{itemize}
\newpage


%%%%%%%%%%%
\section{Funktionale Anforderungen}

\subsection{Eingabe}

\functionality{Eingabefeld}{fnc:input}
\fulfills{crt:text-editor}
\fulfills{crt:input-readonly}
Es gibt ein Eingabefeld, dessen Inhalt als Eingabe für Aurora dient.

\functionality{Zeilennummern}{fnc:ln}
\fulfills{crt:linenumbers}
Links neben dem Eingabefeld befinden sich Zahlen, die die Nummer der Zeile angeben. Diese sind nicht editierbar.

\functionality{Eingabefeld bearbeiten}{fnc:editor}
\fulfills{crt:text-editor}
Der Benutzer kann den Inhalt des Eingabefelds über die Tastatur bearbeiten.

\functionality{Autovervollständigung von Klammern}{fnc:bracket}
\fulfills{crt:autobracket}
Wenn der Benutzer eine Klammer öffnet \enquote{(}, fügt Aurora automatisch eine passende schließende Klammer ein \enquote{)}.

\functionality{Keine Änderungen während der Auswertung}{fnc:no-edit-while-running}
\fulfills{crt:input-readonly}
Der Benutzer kann das Eingabefeld nur genau dann editieren, wenn keine Berechnung am laufen ist.




\subsection{Highlighting}

\functionality{Highlightning von Lambdas und Punkten}{fnc:highlightlambda}
\fulfills{crt:syntax-highlighting}
Lambda-Zeichen \enquote{$\lambda$} und Punkte \enquote{.} werden farblich hervorgehoben.

\functionality{Highlighting von Klammern}{fnc:highlightparentheses}
\fulfills{crt:syntax-highlighting}
Wenn der Eingabezeiger adjazent zu einer öffnenden oder schließenden Klammer steht, werden beide Klammern des Paares farbig hervorgehoben.

\functionality{Highlighting von Funktionsnamen}{fnc:highlightfunctions}
\fulfills{crt:syntax-highlighting}
Während der Benutzer Eingaben tätigt, versucht das Programm Funktionsnamen aus der Standardbibliothek oder Benutzerbibliothek zu erkennen und farblich hervorzuheben.

\functionality{Highlighting des nächsten auszuwertenden Redex}{fnc:highlight-next}
\fulfills{crt:syntax-highlighting-premium}
In jedem Schritt wird im Schrittfeld der nächste auszuwertende Redex farblich hinterlegt.
Die Abstraktion des auszuwertenden Redex wird mit einer Farbe markiert und der Term, der von der Abstraktion reingezogen wird, bekommt eine andere Farbe.

\functionality{Highlighting des zuletzt ausgeführten Redex}{fnc:highlight-prev}
\fulfills{crt:syntax-highlighting-premium}
In jedem Schritt wird der Term, der in der Berechnung für diesen Schritt von einer Abstraktion eingefügt wurde, farbig markiert.


\subsection{Buttons}

\functionality{Run}{fnc:run}
\fulfills{crt:run}
Der \enquote{Run-Button} startet die Auswertung des Inputs. Diese veranlasst den Parser dazu, die $\lambda$-Ausdrücke im Eingabefeld einzulesen.

\functionality{Stop}{fnc:stop}
\fulfills{crt:stop}
Der Benutzer kann eine laufende Berechnung über einen \enquote{Stop}-Button abbrechen. Alle Berechnungsschritte werden verworfen und nichts aus der bisherigen Berechnung wird gespeichert.

\functionality{Pause}{fnc:pause}
\fulfills{crt:pause}
Der Benutzer kann auf den Pause-Button drücken um die laufende Berechnung zu unterbrechen und sich die bisherigen Schritte anzeigen zu lassen. Er kann allerdings, im Gegensatz zum Stop-Button, die Berechnung weiterlaufen lassen.

\functionality{Share}{fnc:share}
\fulfills{crt:share}
Der Benutzer kann mithilfe des Share-Buttons eine Short-URL erstellen, welche den Input und die Benutzerbibliothek enthält. Wenn ein anderer Benutzer diesen Link in seinem Browser lädt, dann öffnet sich das Programm mit gleichem Input und Benutzerbibliothek.



\subsection{Bibliotheken}

\functionality{Standardbibliothek}{fnc:stdlib}
\fulfills{crt:std-library}
Der Benutzer kann Funktionen aus der Standardbibliothek im Eingabefeld verwenden.

\functionality{Benutzerbibliothek}{fnc:userlib-vs-stdlib}
\fulfills{crt:user-library}
Funktionen aus der Benutzerbibliothek können analog zu Funktionen der Standardbibliothek verwendet werden. Es spielt für die Eingabe keine Rolle, ob eine Funktion in der Standard- oder in der Benutzerbibliothek ist.

\functionality{Erweitern der Benutzerbibliothek}{fnc:userlib-extend}
\fulfills{crt:user-library}
Der Benutzer kann Funktionen zur Benutzerbibliothek hinzufügen.

\functionality{Entfernen aus der Benutzerbibliothek}{fnc:userlib-remove}
\fulfills{crt:user-library}
Der Benutzer kann Funktionen aus der Benutzerbibliothek entfernen.

\functionality{Definition einer Funktion}{fnc:func-def}
\fulfills{crt:std-library}
\fulfills{crt:user-library}
Eine definierte Funktion der Standard- oder Benutzerbibliothek hat einen Namen und entspricht genau einem $\lambda$-Term.

\functionality{Äquivalenz von Funktionen und deren Definition}{fnc:func-lambda-equivalent}
\fulfills{crt:std-library}
\fulfills{crt:user-library}
Die Eingabe von definierten Funktionen aus der Standard- und Benutzerbibliothek ist semantisch äquivalent zur Eingabe deren entsprechenden Definition als $\lambda$-Term.









\subsection{Auswertungsstrategien}

\functionality{Normalreihenfolge}{fnc:eval-order-normal}
\fulfills{crt:default-eval-strategy}
$\lambda$-Terme werden standardmäßig in Normalreihenfolge ausgewertet. Das heißt, dass immer der linkeste Redex zuerst ausgewertet wird.

\functionality{Call-by-Name}{fnc:eval-order-call-by-name}
\fulfills{crt:opt-eval-strategy}
$\lambda$-Terme können gemäß der Auswertungsstrategie \enquote{Call-by-Name} ausgewertet werden.

\functionality{Call-by-Value}{fnc:eval-order-call-by-value}
\fulfills{crt:opt-eval-strategy}
$\lambda$-Terme können gemäß der Auswertungsstrategie \enquote{Call-by-Value} ausgewertet werden.

\functionality{Auswahl der Auswertungsstrategie}{fnc:eval-order-options}
\fulfills{crt:opt-eval-strategy}
\fulfills{crt:own-eval-strategy}
Der Benutzer kann zwischen den drei Auswertungsstrategien \enquote{Normalreihenfolge}, \enquote{Call-by-Name} und \enquote{Call-by-Value} wählen, oder selbst den nächsten auszuwertenden Redex auswählen.

\functionality{Benutzerdefinierte Redex Wahl}{fnc:choosing-redex}
\fulfills{crt:own-eval-strategy}
Im Step-Modus kann der Benutzer selbst einen Redex auswählen, der als nächstes ausgewertet wird.




\subsection{Darstellung}

\functionality{Sprache ist auswählbar}{fnc:language-selection}
\fulfills{crt:opt-language}
Der Benutzer kann aus einer Auswahl von menschlichen Sprachen, die Sprache der Benutzeroberfläsche einstellen.

\functionality{Night Mode}{fnc:night-mode}
\fulfills{crt:night-mode}
Das äußere Erscheinungsbild der Applikation kann über die \enquote{Night mode}-Funktion zu einem dunklen Farbschema geändert werden. Dies kann über das Hamburger-Menü ein- oder ausgestellt werden.

\functionality{Mobile Darstellung}{fnc:mobile}
Falls erkannt wird, dass das Programm von einem mobilen Endgerät aus aufgerufen wird, wird eine vereinfachte Version der GUI angezeigt. Hier ist ist kein bearbeiten des Inputs möglich, lediglich der vorhandene Input, wie z.B. der durch eine geteilte URL erhaltene, wird ausgewertet.




\subsection{Hintergrundablauf}

\functionality{$\beta$-Reduktion}{fnc:beta}
Das Programm kann anhand eines vorhandenen $\lambda$-Ausdrucks und einer gegebenen Auswertungsstrategie eine korrekte $\beta$-Reduktion durchführen.

\functionality{Schleifenerkennung}{fnc:loop-test}
\fulfills{crt:loop-detection}
Eine laufende Berechnung wird automatisch auf Schleifen überprüft. Wenn eine Schleife gefunden wurde, warnt das Programm davor.

\functionality{Kein Timeout}{fnc:run-no-timeout}
\fulfills{crt:infiniteloop}
Ein vom Benutzer eingegebenes Programm kann potentiell unendlich laufen.




\subsection{History}

\functionality{Historie}{fnc:localstorage-autosave}
\fulfills{crt:local-sessions}
Eine ausgeführte Benutzereingabe wird automatisch in die Historie eingefügt.

\functionality{Permanenz der Historie}{fnc:localstorage-permanent}
\fulfills{crt:local-sessions}
Einträge in der Historie werden nach schließen des Browsers nicht gelöscht.

\functionality{Wiederherstellen der Historie}{fnc:localstorage-restore}
\fulfills{crt:local-sessions}
Der Benutzer kann Eingaben aus der Historie wiederherstellen.

\functionality{Löschen der Historie}{fnc:localstorage-flush}
\fulfills{crt:local-sessions}
Der Benutzer kann die Einträge der Historie löschen.

\functionality{Benutzerbibliothek in der Historie}{fnc:localstorage-userlib}
\fulfills{crt:local-sessions}
Eine vom Benutzer definierte Funktion wird automatisch in die Historie eingefügt.




\subsection{Sonstige Funktionalität}

\functionality{In neuem Tab öffnen}{fnc:to-new-tab}
\fulfills{crt:to-new-tab}
Ein vom Benutzer ausgewählter Schritt kann in einem neuen Browser-Tab zum Editieren geöffnet werden.

\functionality{LaTeX-Export}{fnc:export-latex}
\fulfills{crt:export-latex}
Der Benutzer kann entweder die Eingabe oder die Eingabe mit Zwischenschritten und Ergebnis in Latexsyntax exportieren. Dies wird automatisch ins Clipboard kopiert, damit der Benutzer dies selbsständig in ein LaTeX Dokument einfügen kann.

\functionality{Shortcuts}{fnc:shortcut}
\fulfills{crt:shortcuts}
Der Benutzer kann Tastenkürzel benutzen um schnelleren Zugriff auf bestimmte Programmfunktionen zu haben.

\functionality{Tutorial}{fnc:tutorial}
\fulfills{crt:tutorial}
Durch drücken des Hilfe-Buttons erscheint ein Tutorial, das dem Benutzer das Programm erklärt und auf Features hinweist.

\functionality{Kommentare}{fnc:comments}
\fulfills{crt:comments}
Der Benutzer kann mit \enquote{\#} eine Zeile bis zum nächsten Zeilenumbruch auskommentieren.




\subsection{Ausgabe}

\functionality{Ausgabefeld nicht editierbar}{fnc:output-readonly}
\fulfills{crt:output-readonly}
Der Inhalt des Ausgabefelds kann nicht bearbeitet werden.

\functionality{Ausgabefeld}{fnc:output}
\fulfills{crt:run}
Falls die Berechnung terminiert, steht das Ergebnis im Ausgabefeld.

\functionality{$\beta$-Reduktionen angezeigen}{fnc:show-beta-reduction}
\fulfills{crt:intermediate-step-output}
Dem Benutzer werden in der GUI nach einer erfolgreichen Berechnung drei Punkte angezeigt. Wenn er auf diese klickt werden ihm alle $\beta$-Reduktion-Schritte angezeigt, die durchgeführt wurden, um auf das Ergebnis zu kommen.

\functionality{De Bruijin-Indizes}{fnc:debruijn-output}
\fulfills{crt:debruijn-output}
Der Benutzer kann einstellen, dass die $\lambda$-Ausdrücke mit De Bruijn-Indizes ausgegeben werden.














\newpage
\section{Nicht-Funktionale Anforderungen}


\nonFunctionality{Korrekte Darstellung in Google Chrome}{nfc:chrome-design}
In \enquote{Google Chrome} 62 wird das Programm korrekt und ohne Fehler jeglicher Art dargestellt.

\nonFunctionality{Benutzbarkeit}{nfc:usability}
Das Programm soll auch ohne Tutorial verständlich bedienbar sein.

\nonFunctionality{Aussehen}{nfc:appearence}
Die Grafische Oberfläche soll schlicht aber modern wirken.

\nonFunctionality{Geschwindigkeit}{nfc:latency}
Das Programm soll sich schnell und responsiv anfühlen. Die Aktion die ein Button ausführt soll schnell erfolgen.

\nonFunctionality{Programmsprache}{crt:default-language}
Die Standard Sprache des Programmes ist Englisch.

\nonFunctionality{Erweiterte Sprachenauswahl}{nfc:opt-language}
Das Programm ist außerdem in den Sprachen Deutsch, Russisch und Französisch verfügbar.

\nonFunctionality{Hinzufügen neuer Sprachen}{nfc:supported-languages}
Die Programmarchitektur soll einfaches Hinzufügen neuer, menschlicher Sprachen unterstützen.

\nonFunctionality{Browserkompatibilität}{nfc:default-browser}
Das Programm funktioniert auf dem Webbrowser \enquote{Google Chrome} 62.

\nonFunctionality{Erweiterte Browserkompatibilität}{nfc:advances-default-browser}
Das Programm funktioniert auf aktuellen Webbrowsern, die Javascript unterstützen.

\nonFunctionality{Hash-Aufwand}{nfc:hash-time}
Die Berechnung der Hashwerte ist nicht mehr als 10\% der Gesamtrechenzeit in Anspruch.

\nonFunctionality{Standardbibliothek}{nfc:standard-library-content}
Die Standardbibliothek kann bis zu 20 vordefinierte Funktionen beinhalten.

\nonFunctionality{Benutzerbibliothek}{nfc:user-library-content}
Die Benutzerbibliothek kann bis zu 10 selbst definierte Funktionen beinhalten.

\nonFunctionality{Begrenzte Zwischenergebnisse}{nfc:limit-intermediate-results}
Die Anzahl der sichtbaren Zwischenergebnisse ist auf 30 beschränkt.

\nonFunctionality{Begrenzter LaTeX export}{nfc:limited-latex-export}
Der LaTeX-Export für die komplette Rechnung kann nur ausgeführt werden, falls weniger als 20 Zwischenergebnisse vorliegen.



\newpage
\section{Tests}

\test{Darstellung in Chrome}{tst:chrome-design}
\tests{nfc:chrome-design}
\tests{fnc:input}
\tests{fnc:ln}
\tests{fnc:mobile}
\tests{fnc:night-mode}
\teststep {Das Programm liegt auf einem Server.}
{Der Benutzer tippt die lokale IP in den Browser \enquote {Google Chrome} ein.}
{Die Webseite wird geöffnet und wird korrekt dargestellt je nach Browserauflösung.}

\teststep {Das Programm liegt auf einem Server.}
{Der Benutzer tippt die Adresse in \enquote{Google Chrome} für mpbile Geräte ein.}
{Die mobile Version der Webseite wird geöffnet und korrekt dargestellt.}

\teststep {Das Programm ist im Default State.}
{Der Benutzer drückt auf den Nachtmodus-Button}
{Das Programm wechselt im Design in den Nachtmodus. Das bisher helle Eingabefenster wird dunkel und die Schrift hell.}


\test{Eingabe und korrektes Ergebnis}{tst:single-step-eval}
\tests{fnc:input}
\tests{fnc:ln}
\tests{fnc:editor}
\tests{fnc:bracket}
\tests{fnc:highlightlambda}
\tests{fnc:highlightparentheses}
\tests{fnc:highlightfunctions}
\tests{fnc:highlight-next}
\tests{fnc:highlight-prev}
\tests{fnc:run}
\tests{fnc:eval-order-normal}
\tests{fnc:beta}
\tests{fnc:output}


\teststep {Das Programm ist geöffnet und es ist im Default-State}
{ Der Benutzer gibt in den Editor \enquote {($\lambda$x.x) z } ein. Dannach drückt er auf den Button \enquote {Run}}
{ Das Programm führt eine $\beta$-Reduktion aus und gibt als Ausgabe \enquote {z} aus. Es wird auch angezeigt, dass es nur eine $\beta$-Reduktion durchgeführt hat.}

\teststep {Das Programm ist geöffnet und es ist im Default-State}
{Der Benutzer gibt den Term \enquote {$\lambda$x.x} in das Eingabefeld ein und drückt auf Run}
{Das Programm kann keine $\beta$-Reduktion durchführen und gibt als Ausgabe $\lambda$x.x}




\teststep {Das Programm ist geöffnet und findet sich im Default-State. An der rechten Seite ist die Standardfunktionsbibliothek implementiert }
{Der Benutzer gibt in den Editor \enquote {plus 2 2} ein und drückt auf den Buttorn \enquote {Run}}
{ Das Programm erkennt das Wort \enquote {plus} aus der Standardbibliothek und ersetzt es durch \enquote {$\lambda$n.$\lambda$m.$\lambda$s.$\lambda$z.n s (m s z)} die 2en erkennt er jeweils als die Churchzahl 2 und ersetzt sie durch \enquote {$\lambda$s.$\lambda$z.s(s z)}. Dann führt das Programm $\beta$-Reduktion aus und bekommt als Ergebnis\enquote {$\lambda$s.$\lambda$z. (s (s (s (s z))))} dies erkennt er ist die Churchzahl 4 und gibt dies aus. }

\teststep { Der vorherige Test wurde soeben durchgeführt}
{ Der Benutzer drückt auf die drei Punkte um alle Schritte zu sehen die bei der $\beta$-Reduktion durchgeführt wurden }
{ Das Programm zeigt folgende Schritte :
\newline ($\lambda$n.$\lambda$m.$\lambda$s.$\lambda$z.n s (m s z)) ($\lambda$s.$\lambda$z.s(s z)) ($\lambda$s.$\lambda$z.s(s z))
\newline ($\lambda$m.$\lambda$s.$\lambda$z.($\lambda$s.$\lambda$z.s(s z)) s (m s z)) ($\lambda$s.$\lambda$z.s(s z))
\newline $\lambda$s.$\lambda$z.($\lambda$s.$\lambda$z.s(s z)) s (($\lambda$s.$\lambda$z.s(s z)) s z)
\newline $\lambda$s.$\lambda$z.($\lambda$z.s(s z)) (($\lambda$s.$\lambda$z.s(s z)) s z)
\newline $\lambda$s.$\lambda$z. ( s ( s (($\lambda$s.$\lambda$z.s(s z)) s z) ))
\newline $\lambda$s.$\lambda$z. ( s ( s (($\lambda$z.s(s z)) z) ))
\newline $\lambda$s.$\lambda$z. ( s ( s ( s (s z))))
 }

\teststep{Das Programm ist im Default-State}
{der Benutzer gibt in den Editor ($\lambda$x.xx)($\lambda$x.xx) ein }
{ das Programm erkennt die Endlosschleife und warnt den Benutzer }

\test{Testen der Standard- und Benutzerbibliotheken}{tst:library}
\tests{fnc:stdlib}
\tests{fnc:uselib-vs-stdlib}
\tests{fnc:userlib-extend}
\tests{fnc:userlib-remove}
\tests{fnc:func-def}
\tests{fnc:func-lambda-equivalent}
\teststep {Das Programm ist im Default-State}
{ Der Benutzer drückt auf den \enquote {Plus} Button und gibt \enquote {pair} und $\lambda$a.$\lambda$b.$\lambda$f.f a b ein }
{Wenn er auf den Button drückt öffnet sich ein Popup-Fenster in dem der Benutzer als Name der neuen Funktion Pair eingeben kann und als lambda term den von ihm gewünschten lambda term eingibt. Dieser Name wird mit dem Lambdaterm gespeichert und man kann im Editor anstelle des Lambdaterms den Namen eingeben. }

\teststep { Der vorherige Test wurde ausgeführt}
{ Der Benutzer gibt in den Editor \enquote {first (pair a b)} ein. Dannach drückt er auf Run}
{ Das Programm erkennt first aus seiner Standardbibliothek und ihm ist $\lambda$p.p($\lambda$a.$\lambda$b.a) zugewiesen. Das Programm erkennt pair aus dem im letzten Testfall hinzugefügten Lambdaterm und kann nun $\beta$-Reduktion druchführen. Das Programm gibt als Ergebnis a aus.}
\teststep {Die vorherigen zwei Tests wurden ausgeführt}
{Der Benutzer löscht den vorher neu definierten \enquote{first} Term aus der Benutzerlibrary}
{Der Name \enquote{first} verschwindet aus der Liste der Namen in der Benutzerbibliothek und dannach wird die funtkion \enquote{first} nicht mehr im Editor erkannt und gehighlightet.}

\teststep{Das Programm befindet sich im Default-State}
{Der Benutzer will einen neuen Eintrag in die Benutzerbibliothek einfügen und nennt seinen neuen Term \enquote{plus} ( Dieser Term ist schon in der Standardbibliothek definiert) }
{Es öffnet sich ein Popup das dem Benutzer sagt, dass er dies nicht darf}

\teststep {Das Programm berechnet zurzeit einen Lambdaterm }
{Der Benutzer drückt auf den Stopp-Button}
{ Das Programm beendet die Berechnung und gibt kein Ergebnis aus }


\test{Auswertungsstrategie}{tst:strategy}
\tests{fnc:eval-order-normal}\tests{fnc:eval-order-call-by-name}\tests{fnc:eval-order-call-by-value}\tests{fnc:eval-order-options}\tests{fnc:choosing-redex}

\teststep {Im Editor steht der Term ($\lambda$t.$\lambda$f.f)(($\lambda$y.($\lambda$x.x x))(($\lambda$x.x)($\lambda$x.x)))($\lambda$t.$\lambda$f.f) sonst ist das Programm im Default-State }
{Der Benutzer lässt den Term ohne eingestellte Auswertungsstrategie (im Default ist das Normalenreihenfolge) und schaut sich den ersten Schritt an. Dann tut er das gleiche mit der Auswertungsstrategie Call-By-Value und  mit Call-By-Name}
{ Bei der Normalreihenfolge und Call-by-Name wird der Redex ($\lambda$t.$\lambda$f.f) als erstes reduziert. Bei Call-By-Value wird der Term ($\lambda$x.x) als erstes reduziert }

\teststep{ Im Editor steht der Lambdaterm ($\lambda$x. f x x) (($\lambda$y. y)z)}
{Der Benutzer drückt auf den Step-Button und drückt auf ($\lambda$y. y) um diesen redex als nächstes zu reduzieren}
{Das Programm wählt diesen Redex für die $\beta$-Reduktion und gibt als nächsten Step \enquote{($\lambda$x. f x x) } aus  }


\teststep { Das Programm ist im Default-State}
{ Der Benutzer gibt ($\lambda$y.$\lambda$x.y x) x a in den Editor ein und drückt auf Run}
{ Durch die Alphakonversion mit De Bruijn-Indizes ist das Ergebnis nicht a  a  }

\teststep {Das Programm hat einen Lambda-Term im Editor stehen} { Der Benutzer drückt auf einen Redex}
{ Dieser Redex wird als nächstes ausgewertet unabhängig davon welche Auswertungsstrategie ausgewählt ist. }

\teststep { Das Programm ist im Default-State}
{ Der Benutzer gibt den (($\lambda$x.x)( in den Editor ein }
{ Das Programm gibt die Fehlermeldung aus, dass dies kein gültiger LambdaTerm ist }

\teststep { Das Programm ist im Default -State }
{ Der Benutzer drückt shift l }
{Im Editor erscheint ein $\lambda$}

\teststep {Das Programm hat einen Lambdaterm ausgerechntet}
{ Der Benutzer drückt auf den Share button und wählt copy-link}
{ Eine gekürzte Url wird in sein Clipboard gespeichert }

\teststep {Der Benutzer hat von vorherigem Test eine Url erhalten}
{Der Benutzer gibt den Link in seine URL Leiste ein }
{ Das Programm öffnet sich mit dem LambdaTerm bereits in der Eingabe }

\teststep {Das Programm ist im Default-State}
{ Der Benutzer gibt sub 1 1 ein und drückt auf Run }
{ Das Programm erkennt die funktion substraction und die churchzahlen und gibt als ergebnis 0 aus. Da das Programm nicht erkennen kann ob es die Churchzahl 0 oder der boolean false ist gibt es immer 0 aus. Im Tutorial des Programmes wird das dem Benutzer erläutert }

\teststep {Das Programm ist im Default-State}
{Der Benutzer gibt ($\lambda$x.xx)($\lambda$x.xx) in den Editor ein.}
{Das Programm erkennt die Endlosschleife und terminiert.}

\teststep {Das Programm ist im Default-State}
{Der Benutzer drückt im Feld Benutzerbibliothek auf den Plus-Button.}
{Es öffnet sich ein Popup, indem der Benutzer eine Funktion definieren kann.}

\test{In neuem Tab öffnen}{tst:to-new-tab}
\tests{fnc:to-new-tab}
\teststep
{Das Programm hat einen eingegebenen $\lambda$-Term erfolgreich fertig ausgewertet und zeigt die Zwischenergebnisse an.}
{Der Benutzer öffnet im ersten Zwischenergebnis das Kontextmenü uns wählt \enquote{To new Tab} aus.}
{Es öffnet sich ein neuer Browser-Tab, in dem der entsprechende Zwischenschritt nun im Eingabefeld steht und editiert werden kann.}





\newpage
\section{Entwicklungsumgebung}
  \begin{description}
	\item[Benutzte Software die für das Erstellen des Programmes verwendet wurden]~\par
	\begin{itemize}
		\item \textbf{Programmiersprache}
		\begin{itemize}
			\item Java 8
		\end{itemize}
		\item \textbf{Build System}
		\begin{itemize}
			\item Bazel, Apache Ant
		\end{itemize}
		\item \textbf{IDE}
		\begin{itemize}
			\item Jeder Entwickler wählt selber. Eclipse, IntelliJ oder SublimeText
		\end{itemize}
		\item \textbf{Webframework}
		\begin{itemize}
			\item Google Web Toolkit \enquote{GWT}
		\end{itemize}
		\item \textbf{Versionskontrolle}
		\begin{itemize}
			\item Git auf git.scc.kit.edu. Webanwendung ist Gitlab
		\end{itemize}
		\item \textbf{Dokument Erstellung}
		\begin{itemize}
			\item LaTeX
		\end{itemize}
		\item \textbf{Testen}
		\begin{itemize}
			\item JUnit
			\item JaCoCo
		\end{itemize}
		\item \textbf{GUI Entwürfe}
			\begin{itemize}
				\item draw.io
				\item Sketch
			\end{itemize}
		\item \textbf{UML und Diagramme zeichnen}
			\begin{itemize}
				\item UMLet
				\item Umbrella
				\item BOUML
				\item Lucidchart
			\end{itemize}
		\item \textbf{endgültige Programmiersprache auf der Website}
			\begin{itemize}
				\item JavaScript
			\end{itemize}
	\end{itemize}
%%%%%%%%%%%%%
\newpage
\appendix
\end{description}
\section{Seitenentwürfe}
\textbf{GUI HIER}
% made via https://gomockingbird.com/projects/mnf0cwf/4gXVnC

%\begin{figure}[hb]
%\fbox{\includegraphics[width=\textwidth]{image/login.png}}
%\caption{\label{fig:homepage}
%Homepage mit Login-Funktion
%}
%\end{figure}

\newpage
\section{Glossar}

%\textbf{Homepage}:
%Seite, die beim Besuchen der Betreiberdomain \emph{ohne Pfad} angezeigt wird. Auch %\enquote{Startseite}.
\textbf{Standardbibliothek}
\newline
Eine Ansammlung von Lambdatermen die einen Funktionsnamen bekommen haben. Die Entwickler von Aurora haben die wichtigsten Lambdaterme zusammen getragen damit der Benutzer häufig vorkommende Lambdaterme nicht selber tippen muss. Der Benutzer kann den Namen der Funktion im Editor verwenden und das Programm ersetzt den Namen automatisch in den gewählten Lambdaterm.

\textbf{Benutzerbibliothek}
\newline
Der Benutzer kann selber Funktionen mit Namen und Lambdaterm definieren. er kann dann den gewählten Namen im Editor verwenden und der Name wird automatisch durch den Lambdaterm ersetzt.

\textbf {Redex}
\newline
Redex steht für \enquote{reducible expression} oder auf deutsch \enquote{reduzibler Ausdruck} ist ein Subterm der durch die Auswertungsstrategien mit Beta-Reductionen reduzierbar sind.
Bei dem Term ($\lambda$x.x) y ist der ($\lambda$x.x) der Redex.

\textbf{Normalform}
\newline
Die Normalform ist ein $\lambda$-term der nicht mehr durch Betareduktion reduzierbar ist. Dies wird im Programm als \enquote{Result} ausgegeben

\textbf{Auswertungsstrategie}
\newline
Die Auswertungsstrategie gibt an welcher Redex als nächstes ausgewertet wird und dann mit Beta-Reduktion reduziert wird.

\textbf{Normalreihenfolge}
\newline
Der linkeste äußerste Redex wird als erstes ausgewertet und reduziert.

\textbf{Call-By-Name}
\newline
Der linkeste äußerste Redex der nicht von einem $\lambda$ umgeben ist wird als erstes ausgewertet und reduziert

\textbf{Call-By-Value}
\newline
Der linkeste Redex der nicht von einem $\lambda$ umgeben ist und dessen Argument ein Wert ist wird als erstes ausgewertet und reduziert.

\textbf{Hover}
\newline
Mit dem Mauszeiger über einem Element \enquote{schewben}, ohne es jedoch zu drücken.

\textbf{IDE}
\newline
Integrierte Entwicklungsumgebung (engl. integrated developement environment). Stellt Features bereit, die die Entwicklung von Software vereinfachen soll.

\textbf{De Bruijn-Indizes}
\newline
Ermöglicht es, $\lambda$-Terme frei von Variablennamen darzustellen.

\textbf{Clipboard}
\newline
(dt. Zwischenablage) Speicher, der für das Kopieren von Daten zwischen zwei Programmen gedacht ist. In der Zwischenablage Gespeichertes kann in anderen Programmen einfach eingefügt werden.

\textbf{localStorage}
\newline
\textcolor{green}{Hier was reindudeln}

\textbf{GWT}
\newline
\textcolor{green}{Hier könnte Ihr Senf stehen}

\textbf{Shortcut}
\newline
\textcolor{green}{Hier könnte Ihr Senf stehen}

\textbf{GUI}
\newline
\textcolor{green}{Hier könnte Ihr Senf stehen}

\textbf{IPD}
\newline
\textcolor{green}{Hier könnte Ihr Senf stehen}

\textbf{Default-State}
\newline
\textcolor{green}{Hier könnte Ihr Senf stehen}

\end{document}
